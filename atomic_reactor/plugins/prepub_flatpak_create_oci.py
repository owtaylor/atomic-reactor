"""
Copyright (c) 2017 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.

Takes the filesystem image created by the Dockerfile generated by
pre_flatpak_create_dockerfile, extracts the tree at /var/tmp/flatpak-build
and turns it into a Flatpak application or runtime.
"""

from flatpak_module_tools.flatpak_builder import FlatpakBuilder

from atomic_reactor.constants import IMAGE_TYPE_OCI, IMAGE_TYPE_OCI_TAR
from atomic_reactor.plugin import PrePublishPlugin
from atomic_reactor.plugins.pre_flatpak_create_dockerfile import get_flatpak_source_info
from atomic_reactor.rpm_util import parse_rpm_output
from atomic_reactor.util import get_exported_image_metadata


# This converts the generator provided by the export() operation to a file-like
# object with a read that we can pass to tarfile.
class StreamAdapter(object):
    def __init__(self, gen):
        self.gen = gen
        self.buf = None
        self.pos = None

    def read(self, count):
        pieces = []
        remaining = count
        while remaining > 0:
            if not self.buf:
                try:
                    self.buf = next(self.gen)
                    self.pos = 0
                except StopIteration:
                    break

            if len(self.buf) - self.pos < remaining:
                pieces.append(self.buf[self.pos:])
                remaining -= (len(self.buf) - self.pos)
                self.buf = None
                self.pos = None
            else:
                pieces.append(self.buf[self.pos:self.pos + remaining])
                self.pos += remaining
                remaining = 0

        return b''.join(pieces)

    def close(self):
        pass


class FlatpakCreateOciPlugin(PrePublishPlugin):
    key = 'flatpak_create_oci'
    is_allowed_to_fail = False

    def __init__(self, tasker, workflow):
        """
        :param tasker: DockerTasker instance
        :param workflow: DockerBuildWorkflow instance
        """
        super(FlatpakCreateOciPlugin, self).__init__(tasker, workflow)

    def _export_container(self, container_id):
        export_generator = self.tasker.d.export(container_id)
        export_stream = StreamAdapter(export_generator)

        outfile, manifestfile = self.builder._export_from_stream(export_stream)

        return outfile, manifestfile

    def _export_filesystem(self):
        image = self.workflow.image
        self.log.info("Creating temporary docker container")
        # The command here isn't used, since we only use the container for export,
        # but (in some circumstances) the docker daemon will error out if no
        # command is specified.
        container_dict = self.tasker.d.create_container(image, command=["/bin/bash"])
        container_id = container_dict['Id']

        try:
            return self._export_container(container_id)
        finally:
            self.log.info("Cleaning up docker container")
            self.tasker.d.remove_container(container_id)

    def run(self):
        self.source = get_flatpak_source_info(self.workflow)
        if self.source is None:
            raise RuntimeError("flatpak_create_dockerfile must be run before flatpak_create_oci")

        self.builder = FlatpakBuilder(self.source, self.workflow.source.workdir,
                                      'var/tmp/flatpak-build',
                                      parse_manifest=parse_rpm_output)

        tarred_filesystem, manifest = self._export_filesystem()
        self.log.info('filesystem tarfile written to %s', tarred_filesystem)
        self.log.info('manifest written to %s', manifest)

        image_components = self.builder.get_components(manifest)
        self.workflow.image_components = image_components

        ref_name, outfile, tarred_outfile = self.builder.build_container(tarred_filesystem)

        metadata = get_exported_image_metadata(outfile, IMAGE_TYPE_OCI)
        metadata['ref_name'] = ref_name
        self.workflow.exported_image_sequence.append(metadata)

        self.log.info('OCI image is available as %s', outfile)

        metadata = get_exported_image_metadata(tarred_outfile, IMAGE_TYPE_OCI_TAR)
        metadata['ref_name'] = ref_name
        self.workflow.exported_image_sequence.append(metadata)

        self.log.info('OCI tarfile is available as %s', tarred_outfile)
